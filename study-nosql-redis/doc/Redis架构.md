# 1. 介绍

​		Redis一句话概括就是高性能key-value内存数据库。具有以下特点

1. 性能极高
2. 丰富的数据类型
3. 丰富的特性，支持publish/subscribe,通知，key过期等特性

## 1.1 



# 2. 数据类型

​		Redis 数据类型分为：字符串类型、散列类型、列表类型、集合类型、有序集合类型,

​		另外支持HyperLogLog GEO BIT

## 2.1  String

## 2.2 

## 2.3

## 2.4

## 2.5

# 4. 特性

## 1.1 键过期

过期策略

## 3.2 发布/订阅

​		目前广泛使用的通信模型，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：订阅者（如客户端）以事件订阅的方式表达出它有兴趣接收的一个事件或一类事件；发布者(如服务器)可将订阅者感兴趣的事件随时通知相关订阅者。

### 3.2.1 

### 3.2.4 缺陷

​		虽然redis实现了发布订阅（publish/subscribe）的功能，但是在通常的情况下是不推荐使用的，如果想使用消息队列这种功能，最好还是使用专业的各种MQ中间件，例如rabbitMQ，rockedMQ,activitedMQ等。

​		概要说一下就是，PUBLISH和SUBSCRIBE的缺陷在于客户端必须一直在线才能接收到消息，断线可能会导致客户端丢失消息，除此之外，旧版的redis可能会由于订阅者消费不够快而变的不稳定导致崩溃，甚至被管理员杀掉。

​		第一个原因是和redis系统的稳定性有关。对于旧版的redis来说，如果一个客户端订阅了某个或者某些频道，但是它读取消息的速度不够快，那么不断的积压的消息就会使得redis输出缓冲区的体积越来越大，这可能会导致redis的速度变慢，甚至直接崩溃。也可能会导致redis被操作系统强制杀死，甚至导致操作系统本身不可用。新版的redis不会出现这种问题，因为它会自动断开不符合client-output-buffer-limit pubsub配置选项要求的订阅客户端

​		第二个原因是和数据传输的可靠性有关。任何网络系统在执行操作时都可能会遇到断网的情况。而断线产生的连接错误通常会使得网络连接两端中的一端进行重新连接。如果客户端在执行订阅操作的过程中断线，那么客户端将会丢失在断线期间的消息，这在很多业务场景下是不可忍受的。

## 3.3 过期监听



## 3.3 布隆过滤器

​		布隆过滤器是Burton Howard Bloom在1970年提出来的，一种空间效率极高的概率型算法和数据结构，主要用来
判断一个元素是否在集合中存在。因为他是一个概率型的算法，所以会存在一定的误差，如果传入一个值去布隆过
滤器中检索，可能会出现检测存在的结果但是实际上可能是不存在的，但是肯定不会出现实际上不存在然后反馈存
在的结果。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter
通过极少的错误换取了存储空间的极大节省。

### 3.2.1 原理

​	布隆过滤器本质是一个位数组，位数组就是数组的每个元素都只占用 1 bit 。每个元素只能是 0 或者 1。这样申请一个 10000 个元素的位数组只占用 10000 / 8 = 1250 B 的空间。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：

1. 使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1
3. 举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 arr。现在要把 https://jaychen.cc插入布隆过滤器中：
   - 对值进行三次哈希计算，得到三个值 n1, n2, n3
   - 把位数组中三个元素 arr[n1], arr[n2], arr[3] 置为 1

​        当要判断一个值是否在布隆过滤器中，对元素再次进行哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。当插入的元素原来越多，位数组中被置为 1 的位置就越多，当一个不在布隆过滤器中的元素，经过哈希计算之后，得到的值在位数组中查询，有可能这些位置也都被置为 1。这样一个不存在布隆过滤器中的也有可能被误判成在布隆过滤器中。但是如果布隆过滤器判断说一个元素不在布隆过滤器中，那么这个值就一定不在布隆过滤器中。简单来说：

- 布隆过滤器说某个元素在，可能会被误判。

- 布隆过滤器说某个元素不在，那么一定不在。

### 3.3.3 算法

# 3. 持久化

RDB快照：fork子进程，通过保存某一时间点内存快照实现，使用BGSAVE命令进行RDB的生成

AOF方式：fork子进程，将每一个写操作进行记录，并在服务器重启后进行重放。

一般推荐使用AOF模式，并将其fsync策略设为每秒。同时定期做RDB的备份

## 3.1 RDB

## 3.2 AOF

