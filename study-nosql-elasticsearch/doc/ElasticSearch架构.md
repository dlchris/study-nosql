# 一. 介绍

​		Redis一句话概括就是高性能key-value内存数据库。具有以下特点

1. 性能极高
2. 丰富的数据类型
3. 丰富的特性，支持publish/subscribe,通知，key过期等特性

## 1.1 



# 二. 数据类型

​		Redis 数据类型分为：字符串类型、散列类型、列表类型、集合类型、有序集合类型,

​		另外支持HyperLogLog GEO BIT

## 2.1  String

## 2.2 List

## 2.3 Set

## 2.4 ZSet

## 2.5 Map

### 

# 三. 持久化 

​		持久化的话是Redis高可用中比较重要的一个环节。

## 3.1 RDB

### 3.1.1 优缺

1. 优点
   - 会生成多个数据文件，每个数据文件分别都代表了某一时刻**Redis**里面的数据，这种方式，有没有觉得很适合做冷备，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了
   - 对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快
2. 缺点
   - RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF则最多丢一秒的数据，数据完整性上高下立判。
   - RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒

## 3.2 AOF

1. 优点
   - **RDB**五分钟一次生成快照，但是**AOF**是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据
   - **AOF**在对日志文件进行操作的时候是以append-only的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损
   - **AOF**的日志是通过一个叫**非常可读**的方式记录的，这样的特性就适合做**灾难性数据误删除**的紧急恢复了，比如公司的实习生通过**flushall**清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份**AOF**日志文件，把最后一条**flushall**命令删了就完事了
2. 缺点
   - 一样的数据，**AOF**文件比**RDB**还要大
   - **AOF**开启后，**Redis**支持写的**QPS**会比**RDB**支持写的要低，他不是每秒都要去异步刷新一次日志嘛**fsync**，当然即使这样性能还是很高，我记得**ElasticSearch**也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的，大家可以思考下为啥哟

## 3.3 两种方式比较

​		单独用RDB会丢失很多数据，单独用**AOF**，数据恢复没**RDB**来的快，真出事的时候第一时间用**RDB**恢复，然后**AOF**做数据补全。冷备热备一起上，才是互联网时代一个高健壮性系统的王道。



# 四. 复制

​		主从复制有以下特点：

1. master可以拥有多个slave
2. 多个slave可以连接同一个master外，还可以连接到其他slave
3. 主从复制不会阻塞master，在同步数据时，master可以继续处理client请求
4. 提高系统的伸缩性
5. 可以在master禁用数据持久化，只需在slave上配置数据持久化

## 4.1 原理

### 4.1.1全量同步

### 4.1.2 增量同步

## 4.2

# 0. 特性

## 4.1 键过期

### 4.1.1 介绍

### 

### 4.1.2 过期键的清除

1. 定时删除
   - 说明：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由时间处理器自动执行键删除操作
   - 优点：保证内存第一时间释放，内存友好
   - 缺点：①需要大量CPU资源；②redis处理时间事件的实现是无序列表，查找一个时间事件的复杂度是O(N)，并不适合用来处理大量时间事件
2. 惰性删除
   - 说明：在键取出时，进行检查，保证键删除在只做不可情况下进行
   - 优点：占用少量CPU资源，CPU资源友好
   - 缺点：内存不友好，未被操作的过期键会一直存在于内存中无法释放，占用大量内存
3. 定期删除
   - 说明：每隔一段时间，执行一次删除操作，并通过限制删除操作的执行频率和时长，以此减少对CPU的负荷；定期删除过期键，有效地减少了因惰性删除带来的内存浪费
4. Redis采用的策略
   - 惰性删除（expireIfNeeded(String key)函数）：每次读取或写入数据库之前，都会调用该函数对输入键进行检查，将过期键删除
   - 定期删除（activeExpireCycle()函数）：尽可能遍历各个数据库的expires字典，随机检查一部分键的过期时间，并删除过期键

### 4.1.3  对持久化及复制的影响

1. RDB
   - 说明：创建新RDB文件时，程序会对键进行检查，过期键不会被写入更新后的RDB文件中
   - 影响：无
2. AOF文件
   - 键过期，但是未删除前
     - 影响：无影响
   - 键过期，已删除
     - 影响：程序会向AOF文件追加一条DEL命令，显式地表示键已删除
3. AOF重写
   - 说明：当AOF重写时，程序会对键进行检查，过期键不会被写入重写的AOF文件中
   - 影响：无
4. 复制
   - 说明：当服务器有附属节点时，过期键的删除由主节点统一控制
   - 服务器是主节点
     - 影响：在它删除一个过期键后，会显式地向所有附属节点发送一条DEL指令
   - 服务器是附属节点
     - 影响：碰到键过期，会向程序返回键已过期的回复（但是此时不执行惰性删除），直到接收到主节点发送过来的DEL命令，附属节点才真正将过期键删除



## 4.2 发布/订阅

### 4.2.1 介绍

​		目前广泛使用的通信模型，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：订阅者（如客户端）以事件订阅的方式表达出它有兴趣接收的一个事件或一类事件；发布者(如服务器)可将订阅者感兴趣的事件随时通知相关订阅者。

### 4.2.2 缺陷

​		虽然redis实现了发布订阅（publish/subscribe）的功能，但是在通常的情况下是不推荐使用的，如果想使用消息队列这种功能，最好还是使用专业的各种MQ中间件，例如rabbitMQ，rockedMQ,activitedMQ等。

​		概要说一下就是，PUBLISH和SUBSCRIBE的缺陷在于客户端必须一直在线才能接收到消息，断线可能会导致客户端丢失消息，除此之外，旧版的redis可能会由于订阅者消费不够快而变的不稳定导致崩溃，甚至被管理员杀掉。

​		第一个原因是和redis系统的稳定性有关。对于旧版的redis来说，如果一个客户端订阅了某个或者某些频道，但是它读取消息的速度不够快，那么不断的积压的消息就会使得redis输出缓冲区的体积越来越大，这可能会导致redis的速度变慢，甚至直接崩溃。也可能会导致redis被操作系统强制杀死，甚至导致操作系统本身不可用。新版的redis不会出现这种问题，因为它会自动断开不符合client-output-buffer-limit pubsub配置选项要求的订阅客户端

​		第二个原因是和数据传输的可靠性有关。任何网络系统在执行操作时都可能会遇到断网的情况。而断线产生的连接错误通常会使得网络连接两端中的一端进行重新连接。如果客户端在执行订阅操作的过程中断线，那么客户端将会丢失在断线期间的消息，这在很多业务场景下是不可忍受的。

### 4.2.3 与ActiveMQ的比较

1. ActiveMQ支持多种消息协议，包括AMQP，MQTT，Stomp等，并且支持JMS规范，但Redis没有提供对这些协议的支持
2. ActiveMQ提供持久化功能，但Redis无法对消息持久化存储，一旦消息被发送，如果没有订阅者接收，那么消息就会丢失
3. ActiveMQ提供了消息传输保障，当客户端连接超时或事务回滚等情况发生时，消息会被重新发送给客户端，Redis没有提供消息传输保障

## 4.3 键空间/事件通知

### 4.3.1 介绍

​		Redis从2.x版本开始，就支持一种基于非持久化消息的、使用发布/订阅模式实现的事件通知机制。所谓基于非连接保持，是因为一旦消息订阅者由于各种异常情况而被迫断开连接，在其重新连接后，其离线期间的事件是无法被重新通知的（一些Redis资料中也称为即发即弃）。而其使用的发布/订阅模式，意味着其机制并不是由订阅者周期性的从Redis服务拉取事件通知，而是由Redis服务主动推送事件通知到符合条件的若干订阅者。

​		Keyspace 通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件（触发某些事件后可以向指定的频道发送通知），该功能需要 Redis 版本大于 2.8。事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发，因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下，直接使用此功能。

​		因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略，所以如果你的程序需要可靠事件通知（reliable notification of events），那么目前的键空间通知可能并不适合你：当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。

​		键空间通知通常是不启用的，因为这个过程会产生额外消耗一些 CPU，所以在默认配置下，该功能处于关闭状态。

### 4.3.1 事件类型

​		对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件：键空间通知（key-space）和键事件通知（key-event）。以 keyspace 为前缀的频道被称为键空间通知（key-space notification）， 而以 keyevent 为前缀的频道则被称为键事件通知（key-event notification）

 		事件是用 __ keyspace@DB __ :KeyPattern 或者 __ keyevent@DB __ :OpsType 的格式来发布消息的。DB表示在第几个库；KeyPattern则是表示需要监控的键模式（可以用通配符）；OpsType则表示操作类型。因此，如果想要订阅特殊的Key上的事件，应该是订阅keyspace。

​		当 del mykey 命令执行时：

- 键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del
- 键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey

### 4.3.2 配置

​		修改 redis.conf 中的  notify-keyspace-events 参数，参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何通知被分发。注意：这个双引号是一定要的，否则配置不成功，启动也不报错。

| 字符 | 发送的通知                                                  |
| ---- | ----------------------------------------------------------- |
| K    | 键空间通知，所有通知以__ keyspace@<db> __为前缀，针对Key    |
| E    | 键事件通知，所有通知以 __ keyevent@<db> __为前缀，针对Event |
| g    | DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知          |
| $    | 字符串命令的通知                                            |
| l    | 列表命令的通知                                              |
| s    | 集合命令的通知                                              |
| h    | 哈希命令的通知                                              |
| z    | 有序集合命令的通知                                          |
| x    | 过期事件：每当有键过期键被删除时发送                        |
| e    | 驱逐事件：每当有键因为maxmemery政策而被删除时发送           |
| A    | 参数g$lshzxe别名                                            |



## 4.4 布隆过滤器

​		布隆过滤器是Burton Howard Bloom在1970年提出来的，一种空间效率极高的概率型算法和数据结构，主要用来
判断一个元素是否在集合中存在。因为他是一个概率型的算法，所以会存在一定的误差，如果传入一个值去布隆过
滤器中检索，可能会出现检测存在的结果但是实际上可能是不存在的，但是肯定不会出现实际上不存在然后反馈存
在的结果。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter
通过极少的错误换取了存储空间的极大节省。

### 4.4.1 原理

​	布隆过滤器本质是一个位数组，位数组就是数组的每个元素都只占用 1 bit 。每个元素只能是 0 或者 1。这样申请一个 10000 个元素的位数组只占用 10000 / 8 = 1250 B 的空间。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：

1. 使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1
3. 举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 arr。现在要把 https://jaychen.cc插入布隆过滤器中：
   - 对值进行三次哈希计算，得到三个值 n1, n2, n3
   - 把位数组中三个元素 arr[n1], arr[n2], arr[3] 置为 1

​        当要判断一个值是否在布隆过滤器中，对元素再次进行哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。当插入的元素原来越多，位数组中被置为 1 的位置就越多，当一个不在布隆过滤器中的元素，经过哈希计算之后，得到的值在位数组中查询，有可能这些位置也都被置为 1。这样一个不存在布隆过滤器中的也有可能被误判成在布隆过滤器中。但是如果布隆过滤器判断说一个元素不在布隆过滤器中，那么这个值就一定不在布隆过滤器中。简单来说：

- 布隆过滤器说某个元素在，可能会被误判。

- 布隆过滤器说某个元素不在，那么一定不在。

### 4.4.2 算法

# 0. 应用

## 1.1 分布式锁

### 1.1.1 为什么要使用分布式锁

​		我们在开发应用的时候，如果需要对某一个共享变量进行多线程同步访问的时候，可以使用我们学到的Java多线程的进行处理，并且可以完美的运行，毫无Bug！

​		注意这是单机应用，也就是所有的请求都会分配到当前服务器的JVM内部，然后映射为操作系统的线程进行处理！而这个共享变量只是在这个JVM内部的一块内存空间！

​		分布式锁一般有三种实现方式：

1. 数据库乐观锁
2. 基于Redis的分布式锁
3. 基于ZooKeeper的分布式锁

### 1.1.2 需要满足的特性

1. 分布式锁应具备哪些条件

   - 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行（互斥性）
   - 高可用、高性能的获取锁与释放锁
   - 具备可重入特性
   - 具备锁失效机制，防止死锁
   - 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败

2. 为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件

   - 互斥性

     在任意时刻只有一个客户端可以获取锁

   - 不会发生死锁

      即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续客户端能加锁，加一个有效时间

   - 持锁人解锁

      加锁和解锁必须是同一个客户端，客户端不能把别人加的锁给解了

   - 可重入

     当一个客户端获取锁对象之后，这个客户端可以再次获取该对象上的锁

   - 具有容错性

     只要大部分的Redis节点正常运行，客户端就可以加锁和解锁

### 1.1.3 分布式锁三种实现方式



